" Plugins {{{
  set nocompatible

  " Load everything in ~/.vim/bundles
  set runtimepath+=~/.vim/bundle/NeoBundle.vim
  call neobundle#begin(expand('~/.vim/bundle/'))

  " let NeoBundle manage itself
  NeoBundleFetch 'Shougo/NeoBundle.vim'

  NeoBundle 'MarcWeber/vim-addon-mw-utils'

  " solarized color scheme
  NeoBundle 'altercation/vim-colors-solarized'

  " status bar
  NeoBundle 'bling/vim-airline'

  " golang support
  NeoBundle 'fatih/vim-go'

  " align text by "=" or ":" or whatever else
  NeoBundle 'godlygeek/tabular'

  " LESS syntax (CSS extension)
  NeoBundle 'groenewege/vim-less'

  " Snippets for use with ultisnips
  NeoBundle 'honza/vim-snippets'

  " julia syntax
  NeoBundle 'JuliaLang/julia-vim'

  " file search
  NeoBundle 'ctrlpvim/ctrlp.vim'

  " quick character search
  NeoBundle 'Lokaltog/vim-easymotion'

  " ack for searching
  NeoBundle 'mileszs/ack.vim'

  " show indents
  NeoBundle 'nathanaelkane/vim-indent-guides'

  " Better C++ syntax highlighting
  NeoBundle 'octol/vim-cpp-enhanced-highlight'

  " file navigation
  NeoBundle 'scrooloose/nerdtree'

  " syntax checking on lots of languages
  NeoBundle 'scrooloose/syntastic'

  " tab completion
  NeoBundle 'Shougo/neocomplete.vim'

  " file/buffer/everything fuzzy search
  NeoBundle 'Shougo/unite.vim'

  " necessary for asynchronous computation
  NeoBundle 'Shougo/vimproc.vim', {
      \ 'build' : {
      \     'windows' : 'make -f make_mingw32.mak',
      \     'cygwin' : 'make -f make_cygwin.mak',
      \     'mac' : 'make -f make_mac.mak',
      \     'unix' : 'make -f make_unix.mak',
      \    },
      \ }

  " snippets engine
  NeoBundle 'SirVer/ultisnips'

  " visual undo tree
  NeoBundle 'sjl/gundo.vim'

  " molokai colorscheme
  NeoBundle 'tomasr/molokai'

  " git integration
  NeoBundle 'tpope/vim-fugitive'

  " delete surrounding parentheses, etc
  NeoBundle 'tpope/vim-surround'

  " Context-aware completion backend.
  if filereadable(expand('~/.at_google'))
    " Google's version of YouCompleteMe conflicts with the public version. Don't
    " enable it if this vimrc is read from a Google machine.
  else
    NeoBundle 'Valloric/YouCompleteMe', {
         \ 'build'      : {
            \ 'mac'     : './install.py',
            \ 'unix'    : './install.py',
            \ 'windows' : 'install.py',
            \ 'cygwin'  : './install.py'
            \ }
         \ }
  endif

  " syntax highlighting for markdown + latex
  NeoBundle 'vim-pandoc/vim-pandoc'
  NeoBundle 'vim-pandoc/vim-pandoc-syntax'

  " kill buffers without messing up window layout
  NeoBundle 'vim-scripts/bufkill.vim'

  " pig syntax
  NeoBundle 'vim-scripts/pig.vim'

  " matlab syntax
  NeoBundle 'vim-scripts/MatlabFilesEdition'

  " swap windows with <leader>ww
  NeoBundle 'wesQ3/vim-windowswap'

  " ctags integration
  NeoBundle 'xolox/vim-easytags'

  " dependency...
  NeoBundle 'xolox/vim-misc'

  NeoBundle 'pangloss/vim-javascript'            " slow slow slow
  " NeoBundle 'Raimondi/delimitMate'               " gets in the way
  " NeoBundle 'sontek/rope-vim'                    " slow slow slow
  " NeoBundle 'majutsushi/tagbar'                  " doesn't work when I need it
  " NeoBundle 'jcf/vim-latex'                      " messes with my shortcuts
  " NeoBundle 'xolox/vim-shell'                    " never use it

  " NeoBundle 'bling/vim-bufferline'               " too many buffers open at a time
  " NeoBundle 'vim-scripts/Auto-Pairs'             " irritating ot use

  call neobundle#end()

  " Prompt user if there are uninstalled bundles
  NeoBundleCheck
" }}}

" Machine-local vimrc {{{
  if filereadable(expand("~/.vimrc-local"))
    source ~/.vimrc-local
  endif
" }}}

" Environment {{{
  if has('win16') || has('win32') || has('win64')
    set runtimepath=$HOME/.vim,$VIM/vimfiles,$VIMRUNTIME " Use /.vim for runtime path on Windows
    set guifont=Consolas:h9:cANSI   " font for GUI on Windows
  endif

  if has('gui_macvim')
    set macmeta   " lets me use <A-...> in MacVim
  endif

  if has('unix') && !has('mac')
    set guifont=Monospace\ 9
  endif

  " ignore these files/folders when tab-completing paths
  set wildignore+=*.pyc,*.o,*.so,*.obj,*.swp,*.zip,*.tar,*.gz,*.exe,*.dll
  set wildignore+=*/tmp/*,*/.git/*,*/.svn/*,*/.hg/*,*/target/*

  set backspace=indent,eol,start  " enable backspace the way you'd expect
  "set clipboard=unnamed    " always copy to windows/mac clipboard for use in other apps
  set hidden                " allow for hidden buffers
  set ffs=unix,dos          " save files with unix line endings
  syntax on                 " syntax highlighting
  filetype plugin indent on " use plugin, indentation style for filetype
  set textwidth=0           " don't automatically split lines after they get too long
  set fileencoding=utf-8    " default to UTF-8
  set switchbuf=usetab      " when using :bn and such, iterate across tabs too
  set mouse=a               " enable mouse usage on some terminals
  set virtualedit=block     " lets you move the cursor past the end of the line when selecting blocks of text
  set lazyredraw            " don't update display while executing a macro
  set formatoptions+=j      " when joining lines prefixed with comment
                            " characters, remove them before joining
" }}}

" Tabs {{{
  set expandtab     " tabs replaced with spaces
  set tabstop=2     " number of spaces a tab counts for
  set shiftwidth=2  " tab appears 2 spaces long
  set softtabstop=2 " backspace deletes tabs of length 2
  set autoindent    " indent same as last line
" }}}

" Backups {{{
  " backups will be written to ~/.vimetc/backup, but must be restored manually.
  " no location history is kept, so if 2 files share the same name the last
  " one you edited will overwrite the other

  " Create a directory (and all its parents) if it's missing, otherwise do
  " nothing.
  function! CreateDirectoryIfMissing(path)
    if !isdirectory(expand(a:path))
      call mkdir(expand(a:path), 'p')
    endif
  endfunction

  set backup                          " enable backups
  let s:etcdir=$HOME.'/.vimetc'
  let &backupdir=s:etcdir.'/backup'   " backup directory
  let &directory=s:etcdir.'/swap'     " swap file directory (crash recovery)
  let &viewdir=s:etcdir.'/views'      " view directory (where you last were)
  if exists("*mkdir")
    call CreateDirectoryIfMissing(s:etcdir  )
    call CreateDirectoryIfMissing(&backupdir)
    call CreateDirectoryIfMissing(&directory)
    call CreateDirectoryIfMissing(&viewdir  )
    " autocmd BufWinLeave * silent! mkview
    "   "save view for files matching '*' when leaving a buffer
    " autocmd BufWinEnter * silent! loadview
    "   "load view for files matching '*' when entering a buffer
  else
    set noswapfile nobackup nowritebackup
  endif
  set viminfo=                          " disable viminfo
"}}}

" Undo History {{{
  if !has('win32') && !has('win64') && v:version >= 703
    set undofile        " Save undo's after file closes
    let &undodir=s:etcdir.'/undo' " where to save undo histories
    call CreateDirectoryIfMissing(&undodir)
    set undolevels=1000     " How many undos
    set undoreload=10000    " number of lines to save for undo
  end
" }}}

" Keys {{{
  " USE "0p INSTEAD TO PASTE LAST YANKED CONTENT
  " " delete doesn't modify clipboard
  " nnoremap dd  "_dd
  " nnoremap d   "_d
  " nnoremap x   "_x
  " nnoremap X   "_X
  " vnoremap d   "_d
  " vnoremap x   "_x
  " vnoremap X   "_X

  " Switching splits
  nnoremap <C-j> <C-W>j
  nnoremap <C-k> <C-W>k
  nnoremap <C-l> <C-W>l
  nnoremap <C-h> <C-W>h

  nnoremap <C-Up>    <C-W>k
  nnoremap <C-Down>  <C-W>j
  nnoremap <C-Left>  <C-W>h
  nnoremap <C-Right> <C-W>l

  " up/down within a single wrapped line
  nnoremap <Up>   gk
  nnoremap <Down> gj
  vnoremap <Up>   gk
  vnoremap <Down> gj
  inoremap <Up>   <C-o>gk
  inoremap <Down> <C-o>gj

  " ALT+(+/-) to resize buffer
  noremap <A-k>   <C-w>+
  noremap <A-j>   <C-w>-
  noremap <A-h>   <C-w><lt>
  noremap <A-l>   <C-w>>

  " change directory to that of current file
  noremap <leader>cd  :cd %:p:h<CR>:pwd<CR>

  " move line up/down
  nnoremap  <C-A-j>   :m+<CR>
  nnoremap  <C-A-k>   :m--<CR>

  " relative line numbers
  noremap <leader>ln  :call ToggleRelativeLineNumbers()<CR>
  function! ToggleRelativeLineNumbers()
    if (&relativenumber == 1)
      set norelativenumber
    else
      set relativenumber
    endif
  endfunction

  " clear highlighted search term
  nnoremap <silent> <C-S-c> :nohlsearch<CR>

  " quicker scroll up/down
  noremap <C-e> 3<C-e>
  noremap <C-y> 3<C-y>

  " start binding window scrolling together
  noremap <leader>sb  :set scrollbind!<CR>

  " Don't use Shift+direction
  noremap <S-Down>  <Down>
  noremap <S-Up>    <Up>

  " start/end of line in insert mode
  inoremap <C-a>  <C-o>^
  inoremap <C-e>  <C-o>$

  " previous/next word in insert mode
  inoremap <C-f>  <C-o>W
  inoremap <C-b>  <C-o>B

  " alternatives to arrow keys in insert mode (steps on switch split keys)
  " inoremap <C-j>  <Down>
  " inoremap <C-k>  <Up>
  " inoremap <C-h>  <Left>
  " inoremap <C-l>  <Right>

  " fix weird behaviour in xterm that results in arrow keys entering 'ABCD'
  noremap OD  <Left>
  noremap OC  <Right>
  noremap OA  <Up>
  noremap OB  <Down>

  " Disable help by F1
  noremap <F1> <Nop>
  inoremap <F1> <Nop>

  " delete surrounding function
  nnoremap <leader>dsf m`F(Bdwxf)x``

  " Disable 'open documentation' shortcut
  nnoremap K <Nop>
  vnoremap K <Nop>

  " delete all trailing whitespace
  nnoremap <leader>dw :%s/\v\s+$//g<CR><C-o>
"}}}

" UI {{{
  if has("gui_running")
    colorscheme solarized
    set background=dark
  else
    colorscheme molokai
  endif
  if $TERM =~ "-256color"
    set t_Co=256      " enable 256 colors
    set t_ut=         " something for playing properly with tmux/screen?
  endif
  " set background=dark " dark background (automatically set by sleepwalker)
  set cursorline          " Hightlight current line
  set ruler               " Show line ruler
  set number              " line numbers
  set hlsearch            " highlight search matches
  set incsearch           " search before pressing <CR>
  set ignorecase          " ignore case in search...
  set smartcase           " ...unless one of the characters is upper case
  set wildmenu            " see options listed in minibuffer
  set scrolloff=3         " minimum number of lines below cursor
  set foldenable          " auto fold code
  set foldmethod=indent   " fold based on indentation. 'syntax' is too slow on large files
  set showcmd             " show partial command in lower right
  set wrap                " wrap lines

  set list                  " enable the following
  set listchars=tab:\ \     " tabs look like spaces
  set listchars+=trail:\~   " ~ for extra whitespace
  set listchars+=extends:>  " character to show at end when wrapping
  set listchars+=precedes:< " character to show at beginning when wrapping

  set completeopt=menuone,longest " popup menu for completions, insert longest match first

  " color trailing whitespace red
  augroup whitespace
    autocmd!
    highlight ExtraWhitespace ctermfg=red guifg=red
    autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
    autocmd BufWinLeave * call clearmatches()
  augroup END
"}}}

" Status Line {{{
  " SEE vim-airline FOR TAB COMPLETION
  " "<path/to/file.pig      Line: 45/200 Col: 10/ 90 Filetype: [pig] Encoding: utf-8
  " set statusline=%F       " full path to this file, 40 char max
  " set statusline+=%=      " switch to right side
  " set statusline+=Line:\ %l/%L  " line numbers
  " set statusline+=\ Col:\ %c/%{col('$')-1}    " col numbers
  " set statusline+=\ Filetype:\ %y             " filetype
  " set statusline+=\ Encoding:\ %{&encoding}   " file encoding
  set laststatus=2        " always show status line
" }}}

" Etc {{{
  set history=1000  " long history
  " set spell         " spell check
"}}}

" Plugins Configuration {{{

  " easytags {{{
    if has('win32') || has('win64')
      let s:ctags_loc = $HOME.'/.vim/lib/ctags58/ctags'
    else
      let s:ctags_loc = 'ctags'
    endif

    let g:easytags_cmd  = s:ctags_loc
    let g:easytags_file = s:etcdir.'/tags'
      " Where easytags saves its tag info
    let g:easytags_on_cursorhold = 0
      " If you stop typing for a bit, :UpdateTags runs
    let g:easytags_autorecurse = 0
      " Scan files in child directories relative to the file being examined
    let g:easytags_auto_update = 0
      " Disable auto updating while keeping auto highlighting
    let g:easytags_events = []
      " Don't update tags automatically

    if !has('win32') && !has('win64')
      call CreateDirectoryIfMissing('/tmp/easytags')
      let g:easytags_by_filetype = '/tmp/easytags'
        " Indepent tag files for each file type, all stored in this folder
    endif

    nnoremap <leader>ut :UpdateTags<CR>
      " Force tag update for all files under the source tree of the
      " currently open file.
  " }}}

  " NERDTree {{{
    nnoremap <leader>nt   :NERDTreeToggle<CR>
    let NERDTreeIgnore = ['\.pyc$']
  " }}}

  " CtrlP {{{
    let g:ctrlp_working_path_mode = 'c'
      " c - the directory of the current file.
      " a - like "c", but only applies when the current working directory outside of
      "     CtrlP isn't a direct ancestor of the directory of the current file.
      " r - the nearest ancestor that contains one of these directories or files:
      "     .git .hg .svn .bzr _darcs
      " w - begin finding a root from the current working directory outside of CtrlP
      "     instead of from the directory of the current file (default). Only applies
      "     when "r" is also present.
      " 0 or <empty> - disable this feature.
      "
      " Note #1: if "a" or "c" is included with "r", use the behavior of "a" or "c" (as
      " a fallback) when a root can't be found.

    noremap <leader>cp :CtrlP<CR>
    noremap <leader>cb :CtrlPBuffer<CR>

    let g:ctrlp_follow_symlinks = 1     " follow symlinks
    let g:ctrlp_clear_cache_on_exit = 0 " keep caches across sessions
    let g:ctrlp_lazy_update = 25        " Don't update until 25 ms of no typing

    let g:ctrlp_custom_ignore = {
      \ 'dir'  : '\v[\/](env|target|dist|.+[.]egg-info)$',
      \ 'file' : '',
      \ 'link' : '',
      \ }

  " }}}

  " python-mode {{{
    let g:pymode_lint = 0           " don't run code checker on save
    let g:pymode_rope = 0           " don't use rope for code analysis
    let g:pymode_indent = 0         " don't step on my indentation
    let g:pymode_options = 0        " don't set wrap, textwidth
    let g:pymode_folding = 1        " do control indentation

    let g:pymode_virtualenv = 0     " don't detect virtualenvs automatically
  " }}}

  " vim-javascript {{{
    let g:html_indent_inctags = "html,body,head,tbody"
    let g:html_indent_script1 = "inc"
    let g:html_indent_style1 = "inc"
  " }}}

  " EasyMotion {{{
    let g:EasyMotion_leader_key = '<Space>'
  " }}}

  " vim-indent-guides {{{
    let g:indent_guides_enable_on_vim_startup = 1

    function! IndentGuidesFor256Color()
      if $TERM =~ "-256color" && g:colors_name == "monokai"
        " 256 colors doesn't play nicely with vim-indent-guides. Set its colors
        " explicitly.
        let g:indent_guides_auto_colors = 0
        highlight IndentGuidesOdd  guibg=darkgrey ctermbg=236
        highlight IndentGuidesEven guibg=darkgrey ctermbg=237
      endif
    endfunction

    augroup indent-guides
      autocmd!
      autocmd VimEnter,Colorscheme * :call IndentGuidesFor256Color()
    augroup END
  " }}}

  " Tabular {{{
    " these patterns only match the first = or : on a line
    nnoremap <Leader>t= :Tabularize /^[^=]*\zs=<CR>
    vnoremap <Leader>t= :Tabularize /^[^=]*\zs=<CR>
    nnoremap <Leader>t: :Tabularize /^[^:]*\zs:<CR>
    vnoremap <Leader>t: :Tabularize /^[^:]*\zs:<CR>
    nnoremap <Leader>t, :Tabularize/(\\|,/l0l0r0r1r0r1r0r1r0r1r0r1<CR>
    vnoremap <Leader>t, :Tabularize/(\\|,/l0l0r0r1r0r1r0r1r0r1r0r1<CR>
  " }}}

  " ack.vim {{{
    nnoremap <Leader>a :Ack<space>
  " }}}

  " gundo.vim {{{
    nnoremap <Leader>gu :GundoToggle<CR>
  " }}}

  " vim-airline {{{
    let g:airline#extensions#bufferline#enabled = 1   " integrate with vim-bufferline
  " }}}

  " unite.vim {{{
    " start unite with search for files and buffers
    nnoremap <leader>un :Unite -start-insert file_rec/async buffer<CR>
  " }}}

  " vim-multiple-cursors {{{
    let g:multi_cursor_quit_key='<C-c>'
  " }}}

  " vim-pandoc {{{
    let g:pandoc#syntax#conceal#use = 0   " disable replacing raw text with pretty versions
  " }}}

  " UltiSnips {{{
    " <CR> to expand snippets. For compatibility with YouCompleteMe. Use C-j
    " and C-k to jump between fields within a snippet.
    let g:UltiSnipsExpandTrigger = "<nop>"
    let g:ulti_expand_or_jump_res = 0
    function! ExpandSnippetOrCarriageReturn()
        let snippet = UltiSnips#ExpandSnippetOrJump()
        if g:ulti_expand_or_jump_res > 0
            return snippet
        else
            return "\<CR>"
        endif
    endfunction
    inoremap <expr><CR> pumvisible() ? "<C-R>=ExpandSnippetOrCarriageReturn()<CR>" : "\<CR>"
  " }}}

  " YouCompleteMe {{{
    " Use Tab and S-Tab to go up/down options list.
    nnoremap <Leader>jd :YcmCompleter GoTo<CR>

    let g:ycm_min_num_of_chars_for_completion = 3

    " Don't let YCM disable Syntastic
    let g:ycm_show_diagnostics_ui = 0
  " }}}
" }}}

" Languages {{{
  " Javascript {{{
    function! JavaScriptFold()
      setlocal foldmethod=syntax
      setlocal foldlevelstart=0
      syntax region foldBraces start=/{/ end=/}/ transparent fold keepend extend

      function! FoldText()
        return substitute(getline(v:foldstart), '{.*', '{...}', '')
      endfunction
      setlocal foldtext=FoldText()
    endfunction

    augroup javascript
      autocmd!
      autocmd FileType javascript :call JavaScriptFold()
    augroup END
  " }}}

  " Pig {{{
    augroup pig
      autocmd!
      autocmd BufNewFile,BufRead *{.pig,.pig.substituted,.pig.expanded} :setlocal filetype=pig syntax=pig
        " whenever you open/read a .pig file, use pig syntax
    augroup END
  " }}}

  " vimrc {{{
    augroup vim
      autocmd!
      autocmd FileType vim :setlocal foldmethod=marker
    augroup END
  " }}}

  " giant files {{{
    let g:LargeFile=1024 * 1024 * 10  " bigger than 10MB? disable some options
    function! DisableBigFileOptions(f)
      if getfsize(a:f) > g:LargeFile
        set eventignore+=FileType     " don't detect filetype
        setlocal noswapfile bufhidden=unload undolevels=-1
      else
        set eventignore-=FileType
      endif
    endfunction

    augroup LargeFile
      autocmd!
      autocmd BufReadPre * let f=expand("<afile>") | call DisableBigFileOptions(f)
    augroup END
  " }}}

  " python {{{
    augroup python
      autocmd!
      autocmd FileType python :setlocal tabstop=2 shiftwidth=2 softtabstop=2
    augroup END
  " }}}

  " golang {{{
    augroup golang
      autocmd!
      autocmd FileType go :setlocal tabstop=4 shiftwidth=4 softtabstop=4 foldnestmax=1
    augroup END
  " }}}
" }}}
